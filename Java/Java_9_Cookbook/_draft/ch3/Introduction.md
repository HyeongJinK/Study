# Introduction

모듈식 프로그래밍을 사용하면 코드를 독립적인 응집력있는 모듈로 구성 할 수 있습니다.이 모듈을 결합하면 원하는 기능을 얻을 수 있습니다. 이렇게 하면 다음과 같은 코드를 작성할 수 있습니다.

* 모듈이 특정 목적으로 구축되기 때문에 응집력이 높아지므로 거기에 있는 코드는 특정 목적을 충족시키는 경향이 있습니다.
* 모듈은 다른 모듈에서 사용할 수있는 API와 만 상호 작용할 수 있기 때문에 캡슐화됩니다.
* 발견 가능성은 개별 유형이 아닌 모듈을 기반으로하므로 신뢰할 수 있습니다. 즉, 모듈이 없으면 종속 모듈이 발견 할 때까지 종속 모듈을 실행할 수 없습니다. 이렇게하면 런타임 오류를 방지하는 데 도움이됩니다.
* 느슨한 결합. 서비스 인터페이스를 사용하면 모듈 인터페이스와 서비스 인터페이스 구현을 느슨하게 결합 할 수 있습니다.

따라서 코드를 설계하고 구성 할 때 고려해야 할 단계는 이제 모듈과 코드 및 모듈 내에서 코드가 구성되는 패키지로 들어가는 구성 파일을 식별하는 것입니다. 그런 다음 모듈의 공개 API를 결정해야 하며 이를 통해 종속 모듈에서 사용할 수 있습니다.

Java Platform Module System의 개발로, **Java Specification Request**(JSR) 376 (https://www.jcp.org/en/jsr/detail?id=376) 에 의해 관리되고 있습니다. JSR은 다음과 같은 근본적인 문제를 해결하는 것이 모듈 시스템의 필요성을 언급합니다.

* **신뢰할 수있는 구성** : 개발자는 프로그램 구성 요소를 구성하기 위해 오래 걸리고 오류가 발생하기 쉬운 클래스 경로 메커니즘으로 어려움을 겪어 왔습니다. 클래스 경로는 구성 요소 간의 관계를 표현할 수 없으므로 필요한 구성 요소가 누락 된 경우 클래스를 사용하려고 시도 할 때까지 발견되지 않습니다. 클래스 패스를 사용하면 동일한 패키지의 클래스를 다른 구성 요소에서 로드 할 수 있으므로 예측할 수 없는 동작과 진단하기 어려운 오류가 발생할 수 있습니다. 제안된 명세는 구성 요소가 다른 구성 요소에 의존한다는 것을 선언하도록 허용 할 것이다.
* **강력한 캡슐화** : Java 프로그래밍 언어 및 JVM의 액세스 제어 메커니즘은 구성 요소가 다른 구성 요소가 내부 패키지에 액세스하지 못하게합니다. 제안된 명세는 컴포넌트가 다른 컴포넌트와 접근 할 수 없는 패키지를 선언 할 수 있도록 한다.

JSR은 다음과 같이 앞의 문제를 해결함으로써 얻은 이점을 나열합니다.

* **확장성있는 플랫폼** : Java SE 플랫폼의 크기가 날로 커짐에 따라 이러한 장치가 SE 클래스 JVM을 실행할 수 있음에도 불구하고 소형 장치에서 사용하기가 점점 더 어려워졌습니다. Java SE 8 (JSR 337)에 도입 된 소형 프로파일은 이러한 점에서 도움이 되지만, 거의 유연하지는 않습니다. 제안 된 사양을 통해 Java SE 플랫폼과 구현을 개발자가 응용 프로그램에서 실제로 요구되는 기능만 포함하는 사용자 정의 구성으로 어셈블 할 수있는 구성 요소 집합으로 분해 할 수 있습니다.
* **플랫폼 무결성 향상** : Java SE 플랫폼 구현 내부의 API를 우연히 사용하는 것은 보안 위험 및 유지 관리 부담입니다. 제안 된 사양에 의해 제공되는 강력한 캡슐화는 Java SE 플랫폼을 구현하는 구성 요소가 내부 API에 대한 액세스를 방지 할 수있게합니다.
* **향상된 성능** : 런타임에 로드되는 클래스가 아닌 다른 특정 구성 요소의 클래스만 클래스가 참조 할 수 있다고 알려진 경우 많은 사전 컴파일 된 전체 프로그램 최적화 기술이 더 효과적 일 수 있습니다. Java SE 플랫폼을 구현하는 구성 요소와 함께 응용 프로그램의 구성 요소를 최적화 할 수있는 경우 성능이 특히 향상됩니다.