# 스트림에서 생성 및 작동

이 레시피에서는 스트림을 생성하는 방법과 스트림에서 방출하는 요소에 적용 할 수있는 작업을 설명합니다.

## 준비하기

스트림을 만드는 방법에는 여러 가지가 있습니다. Java 8 이후, Collection 인터페이스에는,이 콜렉션을 소스로서 가지는 순차 스트림과,이 콜렉션을 소스로서 사용하는 병행 스트림을 돌려주는 parallelStream () 메소드를 돌려주는 stream () 메소드가 있습니다. 즉, Set 및 List를 비롯한 모든 하위 인터페이스에도 이러한 메서드가 있습니다. 또한 8 개의 오버로드 된 stream () 메서드가 해당 배열 또는 하위 집합과 다른 유형의 스트림을 만든 Arrays 클래스에 추가되었습니다.

Stream 인터페이스에는 of (), generate () 및 iterate () 메서드가 있습니다. 특수화 된 인터페이스 인 IntStream, DoubleStream 및 LongStream도 유사한 메소드를 가지며 IntStream에도 range () 및 rangeClosed () 메소드가 있습니다. 둘 다 IntStream을 반환합니다.

스트림을 생성하는 Files.list (), Files.lines (), Files.find (), BufferedReader.lines () 및 기타 여러 메서드가 JDK에 있습니다.

스트림이 생성 된 후에는 다양한 작업을 해당 요소에 적용 할 수 있습니다. 스트림 자체는 데이터를 저장하지 않습니다. 필요한 경우 원본에서 가져 와서 제공합니다. 많은 중간 연산이 스트림을 리턴 할 수 있기 때문에 연산은 유창한 스타일을 사용하여 파이프 라인을 형성 할 수 있습니다. 이러한 작업을 중간 작업이라고합니다. 중간 연산의 예로는 filter () (기준에 일치하는 요소 만 선택), map () (함수에 따라 요소 변환), distinct () (중복 제거), limit () ), sorted () (정렬되지 않은 스트림을 정렬 된 스트림으로 변환) 및 Stream을 리턴하는 다른 메소드 (앞에서 언급 한 스트림을 작성하는 스트림 제외)

파이프 라인은 터미널 작업으로 끝납니다. 스트림 요소의 처리는 실제로 터미널 작업이 실행될 때만 시작됩니다. 그런 다음 모든 중간 작업 (있는 경우)이 처리를 시작하고 스트림이 닫히고 터미널 작업이 실행과 동시에 끝나면 다시 열 수 없습니다. 터미널 작업의 예로는 forEach (), findFirst (), reduce (), collect (), sum (), max () 및 Stream을 반환하지 않는 Stream 인터페이스의 다른 메서드가 있습니다. 터미널 작업은 결과를 반환하거나 부작용을 일으 킵니다.

모든 Stream 메소드는 병렬 처리를 지원하므로 멀티 코어 컴퓨터에서 처리되는 많은 양의 데이터의 경우 특히 유용합니다. 모든 Java Stream API 인터페이스 및 클래스는 java.util.stream 패키지에 있습니다.

이 방법에서는 stream () 메서드로 만든 순차 스트림을 주로 보여줍니다. 병렬 스트림의 처리는 순차 스트림과 크게 다르지 않습니다. 처리 파이프 라인이 다른 처리 환경에 따라 다를 수있는 컨텍스트 상태를 사용하지 않는다는 것을 관찰해야합니다. 이 장의 뒷부분에있는 다른 레서피에서 병렬 처리를 설명합니다.

## 그것을하는 방법 ...

이 섹션에서는 스트림 생성 방법을 설명합니다. 도입부에서 언급했듯이 Set 인터페이스 나 List 인터페이스를 구현하는 각 클래스에는 stream () 메서드와 stream 인터페이스의 인스턴스를 반환하는 parallelStream () 메서드가 있습니다. 지금은 stream () 메소드로 생성 된 순차적 스트림만을 살펴보고 나중에 병렬 스트림으로 돌아갑니다.

1. 스트림 생성의 다음 예제를 고려하십시오.

    ```java
    List.of("This", "is", "created", "by", "List.of().stream()")
            .stream().forEach(System.out::print);
        System.out.println();
        Set.of("This", "is", "created", "by", "Set.of().stream()")
           .stream().forEach(System.out::print);
        System.out.println();
        Map.of(1, "This ", 2, "is ", 3, "built ", 4, "by ", 5,
               "Map.of().entrySet().stream()")
           .entrySet().stream().forEach(System.out::print);
    ```

우리는 유창한 스타일을 사용하여 코드를보다 간결하게 만들었고 출력에서 새로운 라인을 시작하기 위해 System.out.println ()을 삽입했습니다.

2. 앞의 예제를 실행하고 결과를 봅니다.

![](https://www.packtpub.com/graphics/9781786461407/graphics/b3e339d9-4428-48fe-b1df-697713b5f968.png)

List는 매주마다 Set 요소의 순서가 변경되는 동안 요소의 순서를 유지합니다. 이는 주문이 보장되지 않을 때 특정 주문에 의존하여 결함을 발견하는 데 도움이됩니다.

3. Arrays 클래스의 Javadoc을 보라. 오버로드 된 8 개의 stream () 메서드가 있습니다.

    ```java
    static DoubleStream stream(double[] array)
        static DoubleStream stream(double[] array, int startInclusive,
                                   int endExclusive)
        static IntStream stream(int[] array)
        static IntStream stream(int[] array, int startInclusive, 
                                int endExclusive)
        static LongStream stream(long[] array)
        static LongStream stream(long[] array, int startInclusive, 
                                 int endExclusive)
        static <T> Stream<T> stream(T[] array)
        static <T> Stream<T> stream(T[] array, int startInclusive, 
                                    int endExclusive)
    ```

4. 마지막 두 가지 방법의 사용 예를 작성하십시오.    

    ```java
        String[] array = {"That ", "is ", "an ",
                          "Arrays.stream(array)"};
        Arrays.stream(array).forEach(System.out::print);
        System.out.println();
        String[] array1 = { "That ", "is ", "an ", 
                            "Arrays.stream(array,0,2)" };
        Arrays.stream(array1, 0, 2).forEach(System.out::print);
    ```

5. 그것을 실행하고 결과를보십시오 :

![](https://www.packtpub.com/graphics/9781786461407/graphics/6b5bcaf5-3a4c-4b6a-8fec-d0871c60e672.png)

위의 두 번째 예가 의도 한 것처럼 첫 번째 두 요소 (인덱스 0과 1 포함) 만 스트림에 포함되도록 선택되었습니다.

6. 이제 Stream 인터페이스의 Javadoc을 열고 of (), generate () 및 iterate ()의 팩토리 메소드를 확인하십시오.

    ```java
    static <T> Stream<T> of(T t) //Returns Stream of one
    static <T> Stream<T> ofNullable(T t)//Returns Stream of one
    // element, if non-null, otherwise returns an empty Stream
    static <T> Stream<T> of(T... values)
    static <T> Stream<T> generate(Supplier<? extends T> s)
    static <T> Stream<T> iterate(T seed, UnaryOperator<T> f)
    static <T> Stream<T> iterate(T seed, 
        Predicate<? super T> hasNext, UnaryOperator<T> next)
    ```

처음 두 메서드는 간단하므로 데모를 건너 뛰고 세 번째 메서드 인 of ()로 시작합니다. 배열 또는 쉼표로 구분 된 요소 만 사용할 수 있습니다.

7. 다음과 같이 예를 적는다.

    ```java
    String[] array = { "That ", "is ", "a ", "Stream.of(array)" };
        Stream.of(array).forEach(System.out::print); 
        System.out.println();
        Stream.of( "That ", "is ", "a ", "Stream.of(literals)" )
              .forEach(System.out::print);
    ```

8. 실행하고 출력을 관찰하십시오.

![](https://www.packtpub.com/graphics/9781786461407/graphics/cc7db00b-2bf2-4815-8391-bbf330df3239.png)

9. 다음과 같이 generate () 및 iterate () 메서드의 사용 예를 작성합니다.

    ```java
    Stream.generate(() -> "generated ")
              .limit(3).forEach(System.out::print);
    System.out.println();
    System.out.print("Stream.iterate().limit(10): ");
    Stream.iterate(0, i -> i + 1)
            .limit(10).forEach(System.out::print);
    System.out.println();
    System.out.print("Stream.iterate(Predicate < 10): ");
    Stream.iterate(0, i -> i < 10, i -> i + 1)
            .forEach(System.out::print);
    ```

우리는 처음 두 예제에서 생성 된 스트림의 크기에 제한을 두어야했습니다. 그렇지 않으면 무한 할 것입니다. 세 번째 예에서는 반복을 중지해야하는 기준을 제공하는 조건자를 허용합니다.

10. 예제를 실행하고 결과를 관찰하십시오.

![](https://www.packtpub.com/graphics/9781786461407/graphics/270ade1f-4606-4728-8076-858f037a4768.png)

11. 이제 특수화 된 인터페이스 인 IntStream, DoubleStream 및 LongStream에 대한 예제를 작성하십시오. 그들의 구현은 복싱 및 언 박싱의 오버 헤드를 피함으로써 프리미티브를 처리 할 때 성능을 최적화합니다. 또한 IntStream 인터페이스에는 두 개의 스트림 생성 메소드, 즉 range ()와 rangeClosed ()가 있습니다. 둘 다 IntStream을 반환합니다.

    ```java
    System.out.print("IntStream.range(0,10): ");
    IntStream.range(0, 9).forEach(System.out::print);
    System.out.println();
    System.out.print("IntStream.rangeClosed(0,10): ");
    IntStream.rangeClosed(0, 9).forEach(System.out::print);
    ```

12. 그들을 실행하고 출력을 참조하십시오 :

![](https://www.packtpub.com/graphics/9781786461407/graphics/20e4e1b7-4da0-4d37-9e0c-5fcb8ab81508.png)

추측 할 수 있듯이 range () 메서드는 left 매개 변수로 시작하여 right 매개 변수를 포함하지 않고 1의 증분 단계로 정수 시퀀스를 생성합니다. rangeClosed () 메서드는 비슷한 시퀀스를 생성하지만 right 매개 변수가 포함됩니다.

13. 이제 디렉토리의 모든 항목에 대해 Stream <Path>을 반환하는 Files.list (Path dir) 메서드의 예를 살펴 보겠습니다.

    ```java
    System.out.println("Files.list(dir): ");
    Path dir = FileSystems.getDefault()
                .getPath("src/com/packt/cookbook/ch05_streams/");
    try(Stream<Path> stream = Files.list(dir)) {
        stream.forEach(System.out::println);
    } catch (Exception ex){ ex.printStackTrace(); }
    ```

JDK API에서 발췌 한 내용은 다음과 같습니다.이 메소드는 try-with-resources 문 또는 유사한 제어 구조 내에서 스트림 조작이 완료된 후 스트림의 열린 디렉토리가 즉시 닫히도록 보장해야합니다. 이것이 우리가 한 일입니다. 이 경우에는 try-with-resources 문을 사용했습니다. 또는 try ... catch ... finally를 사용하여 finally 블록에서 스트림을 생성하고 닫을 수 있으며 결과는 변경되지 않습니다.

14. 예제를 실행하고 출력을 관찰하십시오.

![](https://www.packtpub.com/graphics/9781786461407/graphics/d6634bbd-9402-4ea3-9cbb-894daf3de424.png)

Stream 인터페이스가 AutoCloseable을 확장하기 때문에 스트림을 명시 적으로 닫아야 할 필요성이 혼란 스러울 수 있습니다.이 때문에 스트림이 자동으로 닫힐 것으로 예상됩니다. 하지만 그렇지 않습니다. 여기에 Stream 인터페이스를위한 Javadoc이 그것에 대해 말해야 할 것이있다. Stream은 BaseStream.close () 메소드를 가지고 있으며 AutoCloseable을 구현한다. 대부분의 스트림 인스턴스는 특수한 자원 관리가 필요없는 콜렉션, 배열 또는 생성 함수에 의해 백업되기 때문에 실제로 사용 후에는 닫을 필요가 없습니다. 일반적으로 Files.lines (Path)에 의해 반환되는 것과 같이 소스가 I / O 채널 인 스트림 만 종료해야합니다. 즉, 프로그래머는 스트림의 소스를 알아야하며 소스의 API에서 필요로하는 경우 스트림을 닫아야합니다.

15. Files.lines () 메서드의 사용 예를 작성하십시오.

    ```java
    System.out.println("Files.lines().limit(3): ");
    String file = "src/com/packt/cookbook/ch05_streams
                    /Chapter05Streams.java";
    try(Stream<String> stream = Files.lines(Paths.get(file))
                                                    .limit(3)){ 
        stream.forEach(l -> { 
        if( l.length() > 0 ) System.out.println("   " + l); 
        } );
    } catch (Exception ex){ ex.printStackTrace(); }
    ```

그 의도는 지정된 파일의 처음 세 줄을 읽고 공백이 3 개인 들여 쓰기로 비어 있지 않은 줄을 인쇄하는 것이 었습니다.

16. 그것을 실행하고 결과를보십시오 :

![](https://www.packtpub.com/graphics/9781786461407/graphics/224d4286-eb95-4c24-9928-0212a6869544.png)

find () 메소드의 사용 예를 작성하십시오.

```java
static Stream<Path>find(Path start, int maxDepth, 
            BiPredicate<Path, BasicFileAttributes> matcher, 
            FileVisitOption... options)
```

17. 이전의 경우와 마찬가지로이 메서드로 생성 된 스트림도 명시 적으로 닫아야합니다. find () 메소드는 주어진 시작 파일과 요청 깊이에 뿌리를 둔 파일 트리를 탐색하고 술어 (파일 속성 포함)와 일치하는 파일의 경로를 리턴합니다. 다음 코드를 지금 작성하십시오.

    ```java
    Path dir = FileSystems.getDefault()
                   .getPath("src/com/packt/cookbook/ch05_streams/");
    BiPredicate<Path, BasicFileAttributes> select = 
        (p, b) -> p.getFileName().toString().contains("Factory");
    try(Stream<Path> stream = Files.find(f, 2, select)){
        stream.map(path -> path.getFileName())
            .forEach(System.out::println);
    } catch (Exception ex){ ex.printStackTrace(); }
    ```

