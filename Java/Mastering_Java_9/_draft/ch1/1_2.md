# Breaking the monolith

수년에 걸쳐 Java 플랫폼의 유틸리티는 지속적으로 발전하여 하나의 커다란 단일체가 되었습니다. 플랫폼을 임베디드 및 모바일 장치에 보다 적합하게 만들려면 Java CDC 및 Java ME와 같은 버전을 제거해야 합니다. 그러나 이들은 JDK가 제공하는 기능성 측면에서 다양한 요구 사항을 가진 최신 응용 프로그램에 충분히 유연하지는 않습니다. 그런 점에서 모듈형 시스템의 필요성은 Java 유틸리티의 모듈화 문제를 해결할 뿐만 아니라 (전체적으로 5,000 개 이상의 Java 클래스와 1500 개 이상의 C++ 소스 파일에 25,0000 개 이상의 코드 줄이 포함됨) 바이러스 요구 사항이되었습니다. 핫스팟 런타임)뿐만 아니라 개발자가 JDK에서 사용되는 것과 동일한 모듈 시스템을 사용하여 모듈러 애플리케이션을 만들고 관리하는 메커니즘을 제공합니다. Java 8은 응용 프로그램이 전체 JDK에서 제공하는 API의 서브 세트 만 사용할 수 있도록 하는 중간 메커니즘을 제공했으며 그 메커니즘은 소형 프로파일이라고 명명되었습니다. 사실, 컴팩트 프로파일은 Java에서 모듈 시스템을 구현하는 데 필요한 JDK의 다양한 개별 구성 요소 간의 종속성을 없애기 위해 수행해야 하는 추가 작업의 기반을 제공합니다.

모듈 시스템 자체는 Jigsaw 프로젝트라는 이름으로 개발되었으며,이를 기반으로 여러 Java 향상 제안과 대상 JSR (376)이 형성되었습니다. Jigsaw 프로젝트의 요구 사항을 해결하기 위해 많은 노력을 기울였습니다. Java 9에 성공적으로 구현 한 기능보다 많은 기능을 제안하여 개념 구현의 증거가있었습니다. JDK 코드 기반의 완전한 재구성이 이루어졌습니다 JDK 배포 가능 이미지의 완전한 재구성과 함께.

완전히 새로운 모듈 시스템을 제공하는 대신 JDK의 일부로 OSGi와 같은 기존 Java 모듈 시스템과 성숙한 Java 모듈 시스템을 채택할지 여부는 커뮤니티에서 상당한 논란이 있었습니다. 그러나 OSGI는 모듈 종속성, 설치, 제거, 모듈 시작 및 중지 (OSGI로 명명 된 번들), 사용자 정의 모듈 클래스 로더 등과 같은 런타임 동작을 대상으로 합니다. 그러나 Project Jigsaw는 응용 프로그램을 컴파일 할 때 종속성 문제가 발생하는 컴파일 타임 모듈 시스템을 대상으로 합니다. 또한 모듈을 JDK의 일부로 설치 및 설치 제거하면 컴파일하는 동안 모듈을 명시적으로 종속성으로 포함 할 필요가 없습니다. 게다가 모듈 클래스의 로드는 클래스 로더 (부트 스트랩과 확장 및 시스템 클래스 로더)의 기존 계층 구조를 통해 가능하지만, OSGI의 모듈 클래스 로더와 거의 유사한 맞춤 모듈 클래스 로더를 사용할 가능성이 있습니다. 그러나 후자는 버려졌다. 우리는 Java에서 모듈 시스템의 세부 사항에 대해 이야기 할 때 Java 모듈 클래스 로딩에 대해 더 자세히 설명 할 것입니다.

Java 모듈 시스템의 추가 이점으로 향상된 보안 및 성능이 있습니다. JDK 및 응용 프로그램을 Jigsaw 모듈로 모듈화함으로써 구성 요소와 해당 도메인간에 잘 정의 된 경계를 만들 수 있습니다. 이러한 관심사의 분리는 플랫폼의 보안 아키텍처와 일치하며 더 나은 리소스 활용을 가능하게합니다. 우리는 이전의 모든 점에 대해 2 개의 세부 챕터와 Java 9를 채택하는 주제에 대해서도 설명했습니다. 또한 기존 프로젝트를 Java 9로 마이그레이션하는 방법에 대해 어느 정도 이해해야합니다.


Over the years, the utilities of the Java platform have continued to evolve and increase, making it one big monolith. In order to make the platform more suitable for embedded and mobile devices, the publication of stripped down editions such as Java CDC and Java ME was necessary. These, however, did not prove to be flexible enough for modern applications with varying requirements in terms of functionality provided by the JDK. In that regard, the need for a modular system came in as a viral requirement, not only to address modularization of the Java utilities (overall, more than 5000 Java classes and 1500 C++ source files with more than 25,0000 lines of code for the Hotspot runtime), but also to provide a mechanism for developers to create and manage modular applications using the same module system used in the JDK. Java 8 provided an intermediate mechanism to enable applications to use only a subset of the APIs provided by the entire JDK, and that mechanism was named compact profiles. In fact, compact profiles also provided the basis for further work that had to be done in order to break dependencies between the various distinct components of the JDK required to enable implementation of a module system in Java.

The module system itself has been developed under the name of project Jigsaw on the basis of which several Java enhancement proposals and a target JSR (376) were formed. Much was put in place to address the requirements of project Jigsaw--there was evidence of concept implementation with more features proposed than the ones that successfully made it into Java 9. Apart from that, a complete restructuring of the JDK code base has been made along with a complete reorganization of the JDK distributable images.

There was considerable controversy in the community as to whether an existing and mature Java module system such as OSGi should be adopted as part of the JDK instead of providing a completely new module system. However, OSGI targets runtime behavior such as the resolution of module dependencies, installation, uninstallation, starting and stopping of modules (also named bundles in terms of OSGI), custom module classloaders, and so on. Project Jigsaw however targets a compile-time module system where resolution of dependencies happen when the application is compiled. Moreover, installing and uninstalling a module as part of the JDK eliminates the need to include it as a dependency explicitly during compilation. Furthermore, loading of module classes is made possible through the existing hierarchy of classloaders (the bootstrap and the extension and system classloaders), although, there was a possibility of using custom module classloaders pretty much similar to the module classloaders of OSGI. The latter was, however, abandoned; we will discuss Java module classloading in more detail when we talk about the details of the module system in Java.

Additional benefits from the Java module system include enhanced security and performance. By modularizing the JDK and applications into Jigsaw modules, we are able to create well-defined boundaries between components and their corresponding domains. This separation of concerns aligns with the security architecture of the platform and is an enabler of better resource utilization. We have dedicated two detailed chapters to all of the preceding points, and to the topic of adopting Java 9 as well, which also requires a degree of understanding on the possible approaches to migrating existing projects to Java 9.